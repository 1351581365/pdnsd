%{
/* conf.l - Lexer for pdnsd config files
   Copyright (C) 2000 Thomas Moestl

This file is part of the pdnsd package.

pdnsd is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

pdnsd is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with pdsnd; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

#include "config.h"
#include "conf-parse.h"
#include "consts.h"

#if !defined(lint) && !defined(NO_RCSIDS)
static char rcsid[]="$Id: conf-lex.l.in,v 1.1 2000/07/20 20:03:10 thomas Exp $";
#endif

extern YYSTYPE yylval;

int br_level=0;
%}

/* In the location below, %option yylineno is inserted by
 * exec-flex.sh in some cases.
 * It causes yylineno to be available in flex, which I prefer
 * for error reporting. It is a little hairy, though, because
 * it is neither part of the POSIX nor offcially documented in
 * the AT&T lex. Look into the Makefile and exec-flex.sh for the 
 * implementation.In short, if your lexer generator chokes on this, 
 * well, you won't get line numbers in the output.*/
@yylineno_option@

%s comment

C_COMM (\/\/)|(#)
C_OPEN  \/\*
C_CLOSE \*\/
%%

<INITIAL>[0-9]+				{sscanf(yytext,"%li",&yylval.num); return NUMBER;}
<INITIAL>"global"			{return GLOBAL;}
<INITIAL>"server"			{return SERVER;}
<INITIAL>"rr"			        {return RR;}
<INITIAL>"source"			{return SOURCE;}

<INITIAL>"perm_cache"			{return PERM_CACHE;}
<INITIAL>"cache_dir"			{return CACHE_DIR;}
<INITIAL>"server_port"                  {return SERVER_PORT;}
<INITIAL>"server_ip"                    {return SERVER_IP;}
<INITIAL>"linkdown_kluge"		{return LINKDOWN_KLUGE;}
<INITIAL>"max_ttl"			{return MAX_TTL;}
<INITIAL>"run_as"			{return RUN_AS;}
<INITIAL>"strict_setuid"		{return STRICT_SETUID;}
<INITIAL>"paranoid"			{return PARANOID;}
<INITIAL>"status_pipe"			{return STATUS_PIPE;}
<INITIAL>"daemon"			{return DAEMON;}
<INITIAL>"tcp_server"			{return C_TCP_SERVER;}
<INITIAL>"pid_file"			{return PID_FILE;}
<INITIAL>"verbosity"			{return C_VERBOSITY;}
<INITIAL>"query_method"			{return C_QUERY_METHOD;}
<INITIAL>"run_ipv4"			{return RUN_IPV4;}
<INITIAL>"debug"			{return C_DEBUG;}

<INITIAL>"ip"				{return IP;}
<INITIAL>"port"				{return PORT;}
<INITIAL>"uptest"			{return UPTEST;}
<INITIAL>"timeout"			{return TIMEOUT;}
<INITIAL>"ping_timeout"			{return PING_TIMEOUT;}
<INITIAL>"ping_ip"			{return PING_IP;}
<INITIAL>"uptest_cmd"			{return UPTEST_CMD;}
<INITIAL>"interval"			{return INTERVAL;}
<INITIAL>"interface"			{return INTERFACE;}
<INITIAL>"purge_cache"			{return PURGE_CACHE;}
<INITIAL>"caching"			{return CACHING;}
<INITIAL>"lean_query"			{return LEAN_QUERY;}

<INITIAL>"a"				{return A;}
<INITIAL>"ptr"				{return PTR;}
<INITIAL>"soa"				{return SOA;}
<INITIAL>"name"				{return NAME;}
<INITIAL>"owner"			{return OWNER;}
<INITIAL>"ttl"			        {return TTL;}
<INITIAL>"file"			        {return FILET;}
<INITIAL>"serve_aliases"	        {return SERVE_ALIASES;}

<INITIAL>"on"				{yylval.num=C_ON;return CONST;}
<INITIAL>"off"				{yylval.num=C_OFF;return CONST;}
<INITIAL>"ping"				{yylval.num=C_PING;return CONST;}
<INITIAL>"none"				{yylval.num=C_NONE;return CONST;}
<INITIAL>"if"				{yylval.num=C_IF;return CONST;}
<INITIAL>"exec"				{yylval.num=C_EXEC;return CONST;}
<INITIAL>"onquery"			{yylval.num=C_ONQUERY;return CONST;}
<INITIAL>"udp_only"			{yylval.num=UDP_ONLY;return CONST;}
<INITIAL>"tcp_only"			{yylval.num=TCP_ONLY;return CONST;}
<INITIAL>"tcp_udp"			{yylval.num=TCP_UDP;return CONST;}

<INITIAL>\"[^\"]*\"			{yylval.nm=(unsigned char *)yytext+1;yylval.nm[strlen((char *)yylval.nm)-1]=(unsigned char)'\0';return STRING;}
<INITIAL>[=;\,\{\}]			{return yytext[0];}
<INITIAL>{C_COMM}[^\n]*			/*munch munch*/

{C_OPEN}				{
						br_level++;
						BEGIN(comment);
					}
<comment>{C_CLOSE}			{
						br_level--;
						if (br_level<0)
							return ERROR;
						if (br_level==0)
							BEGIN(INITIAL);
					}
<comment>.				/*belch.*/
[\ \t]+					/*dish of the day*/
"\n"                                    /*-<=>-*/
.					{return ERROR;}

%%

void lex_set_io(FILE *in, FILE *out)
{
	yyin=in;
	yyout=out;
}

int yywrap()
{
	return 1;
}
